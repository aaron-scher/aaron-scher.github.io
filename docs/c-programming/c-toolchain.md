# The C Toolchain: From Source to Binary

You've written ARM assembly directly — loading values into registers, branching to labels, managing the stack by hand. Now let's see what happens when you write C instead. The compiler produces the same kind of assembly you wrote by hand, plus metadata for the linker. This page shows you how to inspect every step.

!!! tip "Try it yourself"
    Paste any code example into [Compiler Explorer (godbolt.org)](https://godbolt.org/) to see the generated assembly side-by-side with your C code. Use [OnlineGDB](https://www.onlinegdb.com/online_c_compiler) to compile and run.

---

## 1. The Pipeline

Most people think "the compiler" turns source code into an executable. It doesn't — that's four separate tools in a trenchcoat:

```
hello.c → [preprocessor] → hello.i → [compiler] → hello.s → [assembler] → hello.o → [linker] → hello
```

| Stage | Tool | Input | Output | What it does |
|-------|------|-------|--------|--------------|
| Preprocess | `cpp` | `.c` | `.i` | Expands macros, pastes `#include` files |
| Compile | `cc` | `.i` | `.s` | Translates C to assembly |
| Assemble | `as` | `.s` | `.o` | Converts assembly to machine code |
| Link | `ld` | `.o` | executable | Resolves symbols, produces final binary |

!!! note "Key insight"
    The compiler's only job is to produce assembly — the same kind of `.s` file you could write by hand. The assembler and linker are separate steps. When people say "compile" they usually mean all four steps, but understanding the pipeline explains most toolchain errors.

---

## 2. See It Yourself: One File, Five Outputs

Here's the running example we'll use throughout — a function that sums an array and prints the result:

```c
#include <stdio.h>

int sum_array(int arr[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    return sum;
}

int main() {
    int data[] = {1, 2, 3, 4, 5};
    int result = sum_array(data, 5);
    printf("Sum: %d\n", result);
    return 0;
}
```

You can stop `clang` at any stage of the pipeline:

| Command | Output | What you get | What to look for |
|---------|--------|--------------|------------------|
| `clang -E hello.c -o hello.i` | Preprocessed | All `#include` content pasted in, macros expanded | `hello.i` is thousands of lines — your code is at the bottom |
| `clang -S hello.c -o hello.s` | Assembly | Human-readable assembly — this is what the compiler actually produces | Find `sum_array:` — compare it to the assembly you'd write by hand |
| `clang -c hello.c -o hello.o` | Object file | Machine code + symbol table, but not yet executable | Not human-readable — use `nm` and `objdump` to inspect (next section) |
| `clang hello.c -o hello` | Executable | Linked binary — all symbols resolved, ready to run | `./hello` prints `Sum: 15` |
| `clang -S -emit-llvm hello.c` | LLVM IR | Compiler's intermediate representation (bonus) | A portable assembly-like language between C and machine code |

**Try it:** Run `clang -S hello.c` and open `hello.s`. Find the `sum_array` function — you'll see the same `LDR`, `ADD`, and branch instructions you wrote in the ARM tutorials.

---

## 3. What's Inside an Object File?

An object file (`.o`) contains machine code, but it's not runnable yet because it has unresolved references. Two tools let you peek inside:

**`nm` — list symbols:**

```
$ nm hello.o
0000000000000000 T sum_array
0000000000000050 T main
                 U printf
```

| Symbol | Flag | Meaning |
|--------|------|---------|
| `sum_array` | `T` | **Defined** here (T = text/code section) |
| `main` | `T` | **Defined** here |
| `printf` | `U` | **Undefined** — referenced but not defined. The linker must find it. |

**`objdump -d` — disassemble:**

```
$ objdump -d hello.o
```

This shows the machine code translated back to assembly — useful for verifying what the compiler actually generated.

!!! note "The puzzle piece analogy"
    An object file is like a puzzle piece with **tabs** (definitions — symbols marked `T`) and **holes** (references — symbols marked `U`). The linker's job is to snap pieces together by matching each hole to a tab from another object file or library. `printf`'s hole gets filled by the C standard library (`libc`).

---

## 4. Debug Symbols: How the Debugger Maps Back to Your Code

When you run a debugger and set a breakpoint on line 5, how does it know which machine code address that corresponds to? Answer: **DWARF debug information**, generated by the `-g` flag.

```
$ clang -g hello.c -o hello
```

The `-g` flag embeds a mapping from machine code addresses back to your source file. For `sum_array`, the debug info contains:

| Field | Value | What it means |
|-------|-------|---------------|
| Name | `sum_array` | Function name |
| File/Line | `hello.c:3` | Where in your source it's defined |
| Address range | `0x0000-0x004c` | Which machine code bytes belong to this function |
| Return type | `int` | The function's return type |

!!! tip "When to use `-g`"
    Always compile with `-g` during development. It costs nothing at runtime (debug info is metadata, not executed code). Strip it for release builds with `strip` or by omitting `-g`.

---

## 5. ARM Toolchains

When targeting your desktop, `clang` (or `gcc`) handles everything. When targeting an ARM microcontroller like a Cortex-M, you need a **cross-compiler** — a compiler that runs on your machine but produces code for a different architecture.

| Tool | Desktop (native) | ARM Embedded (cross) |
|------|-------------------|----------------------|
| Compiler | `clang` / `gcc` | `arm-none-eabi-gcc` |
| Assembler | `as` | `arm-none-eabi-as` |
| Linker | `ld` | `arm-none-eabi-ld` |
| Debugger | `lldb` / `gdb` | `arm-none-eabi-gdb` |
| Disassembler | `objdump` | `arm-none-eabi-objdump` |

- **`objcopy`** converts between binary formats (e.g., ELF to raw `.bin` for flashing to a microcontroller).
- **OpenOCD** bridges your debugger to the physical hardware via JTAG/SWD.
- **QEMU** emulates ARM hardware so you can test without a physical board.

---

## 6. Quick Reference

| Command | What it does | When you'd use it |
|---------|-------------|-------------------|
| `clang -E file.c` | Preprocess only | Debug macro expansion or `#include` issues |
| `clang -S file.c` | Compile to assembly | See what assembly the compiler generates |
| `clang -c file.c` | Compile + assemble to `.o` | Build object files for separate linking |
| `clang file.c -o out` | Full pipeline to executable | Normal build |
| `clang -g file.c -o out` | Build with debug symbols | Enable debugging with `lldb`/`gdb` |
| `nm file.o` | List symbols | See what a file defines and references |
| `objdump -d file.o` | Disassemble | Inspect generated machine code |
| `clang -S -emit-llvm file.c` | Emit LLVM IR | Explore compiler internals (bonus) |

### Resources

- [Compiler Explorer (godbolt.org)](https://godbolt.org/) — see generated assembly for any C code
- [OnlineGDB C Compiler](https://www.onlinegdb.com/online_c_compiler) — compile and run C online
- [ARM Assembly: Fundamentals](../arm-assembly/arm-assembly-fundamentals.md) — the assembly you'll see in `clang -S` output
